---
title: "Biodiversity EDA — Peter (Individual)"
author: "Yudian (Peter) Pan"
date: "`r format(Sys.Date(), '%B %d, %Y')`"
output:
  html_document:
    toc: true
    toc_depth: 2
    toc_float: true
    number_sections: false
    code_folding: hide
    theme: flatly
    css: peter_eda.css
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = FALSE,
  message = FALSE,
  warning = FALSE,
  fig.align = "center",
  fig.width = 8,
  fig.height = 4.5,
  out.width = "95%"
)

suppressPackageStartupMessages({
  library(sf)
  library(dplyr)
  library(readr)
  library(stringr)
  library(janitor)
  library(glue)
  library(leaflet)
  library(purrr)
  library(ggplot2)
  library(lubridate)
  library(tibble)
  library(tidyr)
  library(htmlwidgets)
  library(rlang)
  library(knitr)
})

# ---------------- Parameters ----------------
AOI_BUFFER_M <- 30              # AOI buffer distance (meters)
WATER_BUF_M  <- 20              # Near-water buffer (meters)
START_DATE   <- as.Date("2020-01-01")

# Toggle console-like debug output inside HTML
VERBOSE <- FALSE
msg <- function(...) if (isTRUE(VERBOSE)) message(glue::glue(...)) else invisible(NULL)

# ---------------- Project root detection ----------------
wd <- getwd()
root_candidates <- unique(c(
  wd,
  normalizePath(file.path(wd, ".."), mustWork = FALSE),
  normalizePath(file.path(wd, "..", ".."), mustWork = FALSE),
  normalizePath(file.path(wd, "..", "..", ".."), mustWork = FALSE),
  normalizePath(file.path(wd, "..", "..", "..", ".."), mustWork = FALSE)
))

ROOT <- wd
for (cand in root_candidates) {
  if (dir.exists(file.path(cand, "Data")) || dir.exists(file.path(cand, "Dataset")) ||
      dir.exists(file.path(cand, "data")) || dir.exists(file.path(cand, "datasets"))) {
    ROOT <- cand
    break
  }
}

# ---------------- Paths ----------------
OUT_DIR <- file.path(ROOT, "Results", "Biodiversity_Peter")
FIG_DIR <- file.path(ROOT, "Figures", "Biodiversity_Peter")
dir.create(OUT_DIR, showWarnings = FALSE, recursive = TRUE)
dir.create(FIG_DIR, showWarnings = FALSE, recursive = TRUE)

DATA_DIRS <- unique(c(
  ROOT,
  wd,
  file.path(ROOT, "Data"),
  file.path(ROOT, "Dataset"),
  file.path(ROOT, "data"),
  "/mnt/data"
))

# Find the first file matching a regex pattern across all roots
find_first <- function(pattern, required = TRUE) {
  files <- unlist(lapply(DATA_DIRS, function(root) {
    if (!dir.exists(root)) return(character(0))
    list.files(root, pattern = pattern, recursive = TRUE, full.names = TRUE)
  }))
  if (length(files)) return(files[1])
  if (required) stop(glue("Missing file for pattern: {pattern}"))
  NA_character_
}

# Find a vector dataset (prefer GeoJSON; else complete SHP)
find_vector <- function(base_pat, prefer_geojson = TRUE, required = TRUE){
  if (prefer_geojson) {
    gj <- unlist(lapply(DATA_DIRS, function(root) {
      if (!dir.exists(root)) return(character(0))
      list.files(root, pattern = glue("{base_pat}.*\\.geojson$"), recursive = TRUE, full.names = TRUE)
    }))
    if (length(gj)) return(gj[1])
  }
  shp <- find_first(glue("{base_pat}.*\\.shp$"), required = required)
  if (is.na(shp)) return(NA_character_)
  stem <- sub("\\.shp$", "", shp, ignore.case = TRUE)
  need <- paste0(stem, c(".shx", ".dbf"))
  if (!all(file.exists(need))) stop(glue("Incomplete SHP for {basename(shp)}"))
  shp
}

# Read sf and ensure EPSG:4326 (FIX: safer CRS check)
safe_read_sf <- function(f){
  x <- suppressMessages(st_read(f, quiet = TRUE))
  crs_epsg <- st_crs(x)$epsg
  if (!is.na(st_crs(x)) && !is.null(crs_epsg) && crs_epsg != 4326L) {
    x <- st_transform(x, 4326)
  }
  x
}

# turn off s2 globally for this knit (avoid spherical union issues)
sf::sf_use_s2(FALSE)

# Helper for nicer HTML tables
kbl <- function(x, caption = NULL) {
  knitr::kable(x, caption = caption, digits = 3)
}

# Helper function: find polygon by name pattern (FIX: reduce code duplication)
find_polygon_by_name <- function(sf_obj, pattern, fallback_all = FALSE) {
  chr_cols <- names(sf_obj)[vapply(sf_obj, function(x) is.character(x) || is.factor(x), logical(1))]
  hits <- sapply(chr_cols, function(col) sum(str_detect(as.character(sf_obj[[col]]), pattern), na.rm = TRUE))
  if (length(hits) && max(hits) > 0) {
    best <- names(which.max(hits))
    sf_obj[str_detect(as.character(sf_obj[[best]]), pattern), ]
  } else if (fallback_all) {
    sf_obj
  } else {
    NULL
  }
}

# Helper: safely get first value or NA
safe_first <- function(x, default = NA_real_) {

  if (length(x) == 0 || all(is.na(x))) return(default)

  x[1]
}
```

```{r data_pipeline, include=FALSE}
# ---------------- Resolve files ----------------
inat_csv <- NA_character_
for (pat in c("observations-631589\\.csv$", "observations-624727\\.csv$", "observations\\.csv$")) {
  candidate <- tryCatch(find_first(pat, required = FALSE), error = function(e) NA_character_)
  if (!is.na(candidate)) { inat_csv <- candidate; break }
}
if (is.na(inat_csv)) stop("iNaturalist CSV not found. Expected e.g. observations-631589.csv")

resolved <- list(
  inat_csv = inat_csv,
  bia      = find_vector("Business.*Areas.*4326"),
  green    = find_vector("Green.*Spaces.*4326"),
  neigh    = find_vector("Neighbourhoods.*4326"),
  trees    = find_vector("TOPO_TREE_WGS84",      prefer_geojson = FALSE),
  water    = find_vector("TOPO_Waterbody_WGS84", prefer_geojson = FALSE),
  woodbine = {
    wb <- unlist(lapply(DATA_DIRS, function(root) {
      if (!dir.exists(root)) return(character(0))
      list.files(root, pattern = "WoodbineBeach.shp$", recursive = TRUE, full.names = TRUE)
    }))
    if (length(wb)) wb[1] else NA_character_
  }
)

# ---------------- AOI + cache ----------------
inat_gj <- file.path(OUT_DIR,"inat_aoi.geojson")
tree_gj <- file.path(OUT_DIR,"trees_aoi.geojson")
aoi_gj  <- file.path(OUT_DIR,"aoi_union_buffer.geojson")

use_cached <- file.exists(inat_gj) && file.exists(tree_gj) && file.exists(aoi_gj)

if (use_cached) {
  inat_aoi  <- safe_read_sf(inat_gj)
  trees_aoi <- safe_read_sf(tree_gj)
  aoi_buf   <- safe_read_sf(aoi_gj)
} else {
  # ---- iNaturalist points ----
  inat <- read_csv(resolved$inat_csv, show_col_types = FALSE) |>
    clean_names() |>
    mutate(
      latitude  = as.numeric(latitude),
      longitude = as.numeric(longitude)
    ) |>
    filter(!is.na(latitude), !is.na(longitude),
           between(latitude,-90,90), between(longitude,-180,180))
  inat_sf <- st_as_sf(inat, coords = c("longitude","latitude"), crs = 4326, remove = FALSE)

  # ---- Base layers ----
  bia   <- safe_read_sf(resolved$bia)
  green <- safe_read_sf(resolved$green)
  trees <- safe_read_sf(resolved$trees)
  neigh <- safe_read_sf(resolved$neigh)

  # ---- Pick Beach BIA by name (robust) ----
  pat_bia <- regex("(^|\\b)(the\\s*beach|the\\s*beaches|beach|beaches)(\\b|$)", ignore_case = TRUE)
  beach_bia <- find_polygon_by_name(bia, pat_bia, fallback_all = TRUE)

  # ---- Woodbine polygon (from Green Spaces or dedicated SHP) ----
  beach <- if (!is.na(resolved$woodbine)) {
    tryCatch(safe_read_sf(resolved$woodbine), error = function(e) NULL)
  } else NULL

  if (is.null(beach) || nrow(beach) == 0) {
    gr_chr <- names(green)[vapply(green, function(x) is.character(x) || is.factor(x), logical(1))]
    idx <- Reduce(`|`, lapply(gr_chr, function(col) str_detect(tolower(green[[col]]), "woodbine")))
    beach <- green[idx,]
    if (nrow(beach) == 0) stop("No 'Woodbine' polygon found in Green Spaces.")
  }

  # ---- Neighbourhood: 'The Beaches' (by name; fallback to code 93 if present) ----
  pat_nb <- regex("(^|\\b)the\\s*beaches(\\b|$)", ignore_case = TRUE)
  neigh_beaches <- find_polygon_by_name(neigh, pat_nb, fallback_all = FALSE)
  if (is.null(neigh_beaches) && "X_id1" %in% names(neigh) && any(neigh$X_id1 == 93, na.rm = TRUE)) {
    neigh_beaches <- neigh |> dplyr::filter(.data$X_id1 == 93)
  }

  # ---- AOI = union(BIA, Woodbine, The Beaches) + buffer (planar) ----
  sanitize <- function(g) {
    g <- st_make_valid(g)
    suppressWarnings(st_collection_extract(g, "POLYGON"))
  }
  parts <- list(sanitize(beach_bia), sanitize(beach))
  if (!is.null(neigh_beaches) && nrow(neigh_beaches) > 0) parts <- c(parts, list(sanitize(neigh_beaches)))

  geoms_4326 <- do.call(c, lapply(parts, st_geometry))
  geoms_proj <- st_transform(geoms_4326, 32617)
  aoi_comb   <- st_combine(geoms_proj)
  aoi_planar <- st_union(aoi_comb)
  aoi_buf    <- st_buffer(aoi_planar, AOI_BUFFER_M) |> st_transform(4326)

  # ---- Filter layers by AOI ----
  inat_aoi  <- st_filter(inat_sf, aoi_buf)
  trees_aoi <- st_filter(trees,   aoi_buf)

  # ---- Write cache ----
  st_write(inat_aoi,  inat_gj, delete_dsn = TRUE, quiet = TRUE)
  st_write(trees_aoi, tree_gj, delete_dsn = TRUE, quiet = TRUE)
  st_write(aoi_buf,   aoi_gj,  delete_dsn = TRUE, quiet = TRUE)

  # Keep key polygons for later summaries (FIX: use <<- instead of assign to GlobalEnv)
  beach_bia <<- beach_bia
  beach <<- beach
  if (!is.null(neigh_beaches)) neigh_beaches <<- neigh_beaches
}

# If we came from cache, (re)load polygons for later summaries
if (!exists("beach_bia") || !exists("beach")) {
  bia   <- safe_read_sf(resolved$bia)
  green <- safe_read_sf(resolved$green)

  pat_bia <- regex("(^|\\b)(the\\s*beach|the\\s*beaches|beach|beaches)(\\b|$)", ignore_case = TRUE)
  beach_bia <- find_polygon_by_name(bia, pat_bia, fallback_all = TRUE)

  gr_chr <- names(green)[vapply(green, function(x) is.character(x) || is.factor(x), logical(1))]
  idx <- Reduce(`|`, lapply(gr_chr, function(col) str_detect(tolower(green[[col]]), "woodbine")))
  beach <- green[idx,]
}

# ---------------- iNat cleaning + classification ----------------
iconic_candidates <- intersect(c("iconic_taxon_name", "taxon_iconic_name"), names(inat_aoi))

inat_clean <- inat_aoi |>
  mutate(
    iconic_tmp = if (length(iconic_candidates) > 0) {
      dplyr::coalesce(!!! rlang::syms(iconic_candidates))
    } else NA_character_,
    category = case_when(
      str_detect(iconic_tmp, regex("Plantae",  TRUE)) ~ "Plants",
      str_detect(iconic_tmp, regex("Aves",     TRUE)) ~ "Birds",
      str_detect(iconic_tmp, regex("Insecta",  TRUE)) ~ "Insects",
      str_detect(iconic_tmp, regex("Mammalia", TRUE)) ~ "Mammals",
      str_detect(iconic_tmp, regex("Reptilia", TRUE)) ~ "Reptiles",
      str_detect(iconic_tmp, regex("Arachnida",TRUE)) ~ "Spiders",
      TRUE ~ "Other"
    )
  ) |>
  select(-iconic_tmp)

id_col <- intersect(c("id", "observation_id"), names(inat_clean))[1]
if (!is.na(id_col) && nzchar(id_col)) {
  id_sym <- rlang::sym(id_col)
  inat_clean <- inat_clean |> arrange(!!id_sym) |> distinct(!!id_sym, .keep_all = TRUE)
}

inat_research <- if ("quality_grade" %in% names(inat_clean)) {
  filter(inat_clean, quality_grade == "research")
} else inat_clean

# ---------------- Summary tables + exports ----------------
AREA_CRS <- 32617
area_ha <- aoi_buf |> st_transform(AREA_CRS) |> st_area() |> as.numeric() / 10000
species_n <- if ("scientific_name" %in% names(inat_clean)) n_distinct(inat_clean$scientific_name) else NA_integer_

summary_tbl <- tibble(
  total_obs      = nrow(inat_clean),
  unique_species = species_n,
  tree_points    = nrow(trees_aoi),
  area_ha        = round(sum(area_ha), 2),
  species_per_ha = round(species_n / sum(area_ha), 3),
  aoi_buffer_m   = AOI_BUFFER_M
)

write_csv(summary_tbl, file.path(OUT_DIR, "bio_summary_final.csv"))

cat_summary <- inat_clean |> st_drop_geometry() |> count(category, name = "observations") |> arrange(desc(observations))
write_csv(cat_summary, file.path(OUT_DIR, "category_summary.csv"))

# Multi-area summary (BIA vs Woodbine vs Neighbourhood vs AOI)
summarise_area <- function(name, poly){
  poly <- st_make_valid(poly)
  a_ha <- st_area(st_transform(poly, AREA_CRS)) |> as.numeric() / 10000
  inat_s  <- suppressWarnings(st_filter(inat_clean, poly))
  trees_s <- suppressWarnings(st_filter(trees_aoi,   poly))
  tibble(
    area           = name,
    total_obs      = nrow(inat_s),
    unique_species = if ("scientific_name" %in% names(inat_s)) n_distinct(inat_s$scientific_name) else NA_integer_,
    tree_points    = nrow(trees_s),
    area_ha        = round(sum(a_ha), 2),
    species_per_ha = round(n_distinct(inat_s$scientific_name) / sum(a_ha), 3)
  )
}

areas_list <- list(
  "Beach BIA" = beach_bia,
  "Woodbine Beach" = beach,
  "AOI buffer (union)" = aoi_buf
)
if (exists("neigh_beaches") && !is.null(neigh_beaches) && nrow(neigh_beaches) > 0) {
  areas_list[["The Beaches (Neighbourhood)"]] <- neigh_beaches
}

summary_by_area <- bind_rows(purrr::imap(areas_list, ~ summarise_area(.y, .x)))
write_csv(summary_by_area, file.path(OUT_DIR, "bio_summary_by_area.csv"))

# Tree density (trees per km^2)
tree_density_tbl <- summary_by_area |>
  mutate(
    area_km2 = area_ha / 100,
    trees_per_km2 = ifelse(area_km2 > 0, tree_points / area_km2, NA_real_)
  ) |>
  select(area, tree_points, area_ha, trees_per_km2) |>
  arrange(area)

write_csv(tree_density_tbl, file.path(OUT_DIR, "tree_density_by_area.csv"))

# Time series helper objects
if ("observed_on" %in% names(inat_clean)) {
  yearly <- inat_clean |>
    st_drop_geometry() |>
    mutate(date = as.Date(observed_on)) |>
    filter(!is.na(date), date >= START_DATE) |>
    count(year = lubridate::year(date), name = "observations") |>
    arrange(year)

  monthly <- inat_clean |>
    st_drop_geometry() |>
    mutate(date = as.Date(observed_on)) |>
    filter(!is.na(date), date >= START_DATE) |>
    count(month = lubridate::floor_date(date, "month"), name = "n")
} else {
  yearly  <- NULL
  monthly <- NULL
}

# Convenience exports from consolidated workflow
if ("scientific_name" %in% names(inat_clean)) {
  top_species_tbl <- inat_clean |> st_drop_geometry() |> count(scientific_name, sort = TRUE) |> slice_head(n = 10)
  write_csv(top_species_tbl, file.path(OUT_DIR, "top_species.csv"))
}
if ("user_login" %in% names(inat_clean)) {
  top_observers_tbl <- inat_clean |> st_drop_geometry() |> count(user_login, sort = TRUE) |> slice_head(n = 10)
  write_csv(top_observers_tbl, file.path(OUT_DIR, "top_observers.csv"))
}
```

# Introduction

This individual report provides an exploratory analysis of biodiversity-related features within **The Beach BIA** area. The analysis uses iNaturalist observations together with spatial layers (tree inventory, greenspaces, and waterbodies) to (i) identify **where** observations are concentrated and (ii) summarize **how** observation volume varies across time and across spatial units (Beach BIA vs Woodbine Beach vs the broader AOI).

To keep this deliverable consistent with our group work, the data pipeline and spatial definitions reuse the same consolidated workflow (AOI union + buffer, consistent CRS handling, and the same iNaturalist classification rules). This document is written in a **report-style HTML format** (text + figure, minimal console noise) so it can be submitted as a standalone artifact.

# Research objectives

This EDA focuses on two questions:

1. **iNaturalist patterns:** Are there identifiable spatial and temporal patterns in the number of observations inside the AOI?
2. **Tree density:** How does tree density vary across the Beach BIA commercial strip relative to nearby areas?

# Data description

This EDA uses four datasets:

- **iNaturalist observations (CSV):** user-reported wildlife observations with geographic coordinates and observation dates. Observations are filtered to the AOI and deduplicated by observation ID when available.
- **Tree inventory (vector layer):** point locations of trees from Toronto Open Data.
- **Greenspaces (vector layer):** polygon boundaries of designated greenspaces.
- **Waterbodies (vector layer):** polygon boundaries of water features.

# Methods and data preparation

## Area of interest (AOI)

The AOI is constructed as the **union** of: (i) the Beach BIA polygon, (ii) the Woodbine Beach polygon, and (iii) (when available) the broader "The Beaches" neighbourhood polygon, followed by a **buffer of `r AOI_BUFFER_M` meters** to capture nearby observations at the boundary. All spatial operations are performed in a projected CRS for buffering/union, then returned to EPSG:4326 for mapping.

## Cleaning and classification

- iNaturalist points are converted to an `sf` point object and filtered to valid latitude/longitude.
- Observations are assigned to broad categories using the iconic taxon field (Plants, Birds, Insects, Mammals, Reptiles, Spiders, Other).
- For reproducibility and convenient reuse, intermediate objects are cached to GeoJSON under `Results/Biodiversity_Peter/`.

## Snapshot summary

Within the AOI (union + buffer), the filtered dataset contains **`r summary_tbl$total_obs` observations** and **`r summary_tbl$unique_species` unique species**, over an area of **`r summary_tbl$area_ha` hectares**. The tree inventory contributes **`r summary_tbl$tree_points` tree points** in the same AOI.

```{r tbl_summary, echo=FALSE}
kbl(summary_tbl, caption = "Table 1. Summary statistics for the AOI used in the biodiversity EDA.")
```

# Exploratory data analysis

## Question 1 — Spatial and temporal patterns in iNaturalist observations

### Fig 1. Spatial distribution of observations and trees

The map below overlays iNaturalist observations (grouped by broad category) and tree points within the AOI. Visual clustering near greenspaces and the lakeshore suggests that biodiversity observations are not uniformly distributed across the district; instead, they tend to concentrate around natural corridors and park-like areas.

```{r fig1_map_categories_trees}
m <- leaflet(options = leafletOptions(minZoom = 10)) |>
  addProviderTiles("CartoDB.Positron") |>
  addPolygons(data = aoi_buf, label = "AOI (union) buffer", color = "#444", weight = 2, fillOpacity = 0.05) |>
  addCircleMarkers(data = filter(inat_clean, category == "Plants"),   radius = 2, color = "#2ca25f", stroke = FALSE, fillOpacity = 0.9, group = "Plants") |>
  addCircleMarkers(data = filter(inat_clean, category == "Birds"),    radius = 2, color = "#3182bd", stroke = FALSE, fillOpacity = 0.9, group = "Birds") |>
  addCircleMarkers(data = filter(inat_clean, category == "Insects"),  radius = 2, color = "#fd8d3c", stroke = FALSE, fillOpacity = 0.9, group = "Insects") |>
  addCircleMarkers(data = filter(inat_clean, category == "Mammals"),  radius = 2, color = "#756bb1", stroke = FALSE, fillOpacity = 0.9, group = "Mammals") |>
  addCircleMarkers(data = filter(inat_clean, category == "Reptiles"), radius = 2, color = "#41ab5d", stroke = FALSE, fillOpacity = 0.9, group = "Reptiles") |>
  addCircleMarkers(data = filter(inat_clean, category == "Spiders"),  radius = 2, color = "#636363", stroke = FALSE, fillOpacity = 0.9, group = "Spiders") |>
  addCircleMarkers(data = filter(inat_clean, category == "Other"),    radius = 2, color = "#969696", stroke = FALSE, fillOpacity = 0.8, group = "Other") |>
  addCircleMarkers(data = trees_aoi, radius = 2, color = "green", stroke = FALSE, fillOpacity = 0.6, group = "Trees") |>
  addLayersControl(
    overlayGroups = c("Plants","Birds","Insects","Mammals","Reptiles","Spiders","Other","Trees"),
    options = layersControlOptions(collapsed = FALSE)
  ) |>
  addLegend(
    "bottomright",
    colors = c("#2ca25f","#3182bd","#fd8d3c","#756bb1","#41ab5d","#636363","#969696","green"),
    labels = c("Plants","Birds","Insects","Mammals","Reptiles","Spiders","Other","Trees"),
    title = "Layers"
  )

m

# Save a standalone copy (optional; useful for sharing outside the knitted report)
saveWidget(m, file.path(OUT_DIR, "map_categories_and_trees.html"), selfcontained = TRUE)
```

### Fig 2. Composition of observations by broad category

The figure below summarizes the distribution of observations across broad categories. Because iNaturalist is user-driven, this composition reflects both ecological presence and observer behavior (e.g., which taxa are easier to detect and report).

```{r fig2_obs_by_category, fig.cap="Figure 2. Observation counts by broad iNaturalist category inside the AOI."}
fig2_cat <- cat_summary |>
  mutate(category = factor(category, levels = category[order(observations, decreasing = TRUE)]))

p_cat <- ggplot(fig2_cat, aes(x = category, y = observations)) +
  geom_col() +
  labs(
    x = NULL,
    y = "Number of observations",
    title = "iNaturalist observations by species category (The Beach BIA AOI)"
  ) +
  theme_minimal()

p_cat

ggsave(file.path(FIG_DIR, "fig2_obs_by_category.png"), p_cat, width = 8, height = 4, dpi = 300)
```

### Fig 3. Annual observation trend since 2020

Aggregating by year provides a simple view of temporal variation. In practice, changes over time can reflect both ecological variation and shifts in participation (more users, more reporting, or targeted observation events).

```{r fig3_annual_obs, fig.cap="Figure 3. Annual observation counts within the AOI (2020 to present)."}
if (!is.null(yearly)) {
  p_year <- ggplot(yearly, aes(x = factor(year), y = observations)) +
    geom_col() +
    labs(
      x = "Year",
      y = "Number of observations",
      title = "Annual iNaturalist observations in The Beach BIA AOI"
    ) +
    theme_minimal()

  print(p_year)
  ggsave(file.path(FIG_DIR, "fig3_annual_obs.png"), p_year, width = 8, height = 4, dpi = 300)
}
```

## Question 2 — Tree density along the commercial strip

To complement the spatial maps, we compute a simple density metric: **trees per km^2**, using each unit's area and the number of tree points that fall inside it.

```{r tbl_tree_density}
kbl(tree_density_tbl, caption = "Table 2. Tree density summary (trees per km^2) across spatial units.")
```

```{r tree_density_values, include=FALSE}
# FIX: Pre-compute values safely to avoid inline R code errors
density_bia <- safe_first(tree_density_tbl$trees_per_km2[tree_density_tbl$area == "Beach BIA"], 0)
density_woodbine <- safe_first(tree_density_tbl$trees_per_km2[tree_density_tbl$area == "Woodbine Beach"], 0)
density_aoi <- safe_first(tree_density_tbl$trees_per_km2[tree_density_tbl$area == "AOI buffer (union)"], 0)
```

In Table 2, the Beach BIA density is approximately **`r round(density_bia, 0)` trees per km^2**, compared with **`r round(density_woodbine, 0)` trees per km^2** in Woodbine Beach and **`r round(density_aoi, 0)` trees per km^2** at the AOI level. These summaries are sensitive to how each polygon is defined (area) and how tree points are recorded, so they should be interpreted as *comparative* rather than absolute measures.

### Fig 4. Tree density heatmap inside the Beach BIA

The interactive heatmap emphasizes where tree points are most concentrated inside the Beach BIA polygon. This provides a visual complement to Table 2 by highlighting local clustering rather than a single area-average value.

```{r fig4_tree_heatmap}
if (requireNamespace("leaflet.extras", quietly = TRUE)) {
  trees_bia <- suppressWarnings(st_filter(trees_aoi, beach_bia))

  m_tree_heat <- leaflet(options = leafletOptions(minZoom = 10)) |>
    addProviderTiles("CartoDB.Positron") |>
    addPolygons(data = beach_bia, color = "#cc0000", weight = 2, fillOpacity = 0.05, group = "Beach BIA") |>
    leaflet.extras::addHeatmap(data = trees_bia, radius = 12, blur = 18, max = 0.6)

  saveWidget(m_tree_heat, file.path(OUT_DIR, "map_tree_density_heat.html"), selfcontained = TRUE)
  m_tree_heat
}
```

# Discussion and next steps

This EDA suggests that biodiversity-related activity (as proxied by iNaturalist observations) is spatially structured in the Beach BIA AOI: observations cluster around greenspaces and the lakeshore, while the commercial corridor appears comparatively sparse. Tree density patterns similarly show heterogeneity across space—area-level averages are informative, but the heatmap highlights localized concentration and potential gaps.

**Limitations and interpretation notes:**

- iNaturalist is **user-generated**: observation counts reflect both ecological presence and observer effort, and may over-represent easily observed or popular taxa.
- Spatial layers come from different sources and vintages; polygon boundaries and point inventories can shift with updates, which affects counts near borders.
- Buffers (AOI and near-water) are small by design; results may change if these thresholds are adjusted.

If this work is extended to a simple modelling step, two natural directions are:

- **Spatial intensity modelling:** treat observations as a point process intensity surface and compare intensity near greenspace/water vs farther away.
- **Count modelling across units:** aggregate observations to small grid cells or street segments and model counts using predictors such as distance-to-water, greenspace proportion, and tree density.

# Appendix {-}

<details>
<summary><strong>Click to expand: additional exploration and saved outputs</strong></summary>

### A1. Monthly trend (optional)

This figure refines Fig 3 by showing within-year seasonality. Peaks likely reflect both ecological seasonality and reporting intensity.

```{r app_monthly}
if (!is.null(monthly)) {
  ggplot(monthly, aes(month, n)) +
    geom_col() +
    scale_x_date(date_labels = "%Y-%m", date_breaks = "2 months", expand = c(0.01,0.01)) +
    labs(x = "Month", y = "Observations", title = "iNaturalist observations per month") +
    theme_minimal() +
    theme(axis.text.x = element_text(angle = 45, hjust = 1))
}
```

### A2. Neighbourhood richness choropleth (within AOI)

This map compares neighbourhood-level richness (unique species) within the AOI. It helps identify which surrounding neighbourhoods may be driving the AOI-level totals.

```{r app_neigh_richness}
neigh <- safe_read_sf(resolved$neigh)
neigh_clip <- suppressWarnings(st_intersection(st_make_valid(neigh), st_make_valid(aoi_buf)))

neigh_name_col <- names(neigh_clip)[str_detect(names(neigh_clip), regex("NAME|NEIGH|AREA", TRUE))][1]
if (is.na(neigh_name_col)) neigh_name_col <- names(neigh_clip)[1]

inat_neigh <- st_join(inat_clean, neigh_clip, left = FALSE)

obs_by_neigh <- inat_neigh |> st_drop_geometry() |> count(neigh = .data[[neigh_name_col]], name = "obs")
sp_by_neigh  <- inat_neigh |> st_drop_geometry() |> group_by(neigh = .data[[neigh_name_col]]) |>
  summarise(unique_species = n_distinct(.data$scientific_name), .groups = "drop")

neigh_area <- neigh_clip |>
  mutate(area_ha = as.numeric(st_area(st_transform(geometry, AREA_CRS))) / 10000) |>
  st_drop_geometry() |>
  select(neigh = all_of(neigh_name_col), area_ha)

neigh_summary <- obs_by_neigh |>
  left_join(sp_by_neigh, by = "neigh") |>
  left_join(neigh_area,  by = "neigh") |>
  mutate(species_per_ha = round(unique_species / area_ha, 3)) |>
  arrange(desc(unique_species))

write_csv(neigh_summary, file.path(OUT_DIR, "neighbourhood_biodiversity_summary.csv"))

neigh_poly_metric <- neigh_clip |>
  left_join(neigh_summary, by = setNames("neigh", neigh_name_col)) |>
  mutate(label_rich = paste0(
    .data[[neigh_name_col]],
    "<br>Species: ", ifelse(is.na(unique_species), 0, unique_species),
    "<br>Area(ha): ", ifelse(is.na(area_ha), NA, round(area_ha, 1)),
    "<br>Sp/ha: ", ifelse(is.na(species_per_ha), NA, species_per_ha)
  ))

# FIX: safer colorBin with dynamic bins
n_unique <- length(unique(na.omit(neigh_poly_metric$unique_species)))
n_bins <- min(6, max(2, n_unique))
pal_rich <- colorBin("YlGnBu", neigh_poly_metric$unique_species, bins = n_bins, na.color = "#cccccc")

leaflet(options = leafletOptions(minZoom = 10)) |>
  addProviderTiles("CartoDB.Positron") |>
  addPolygons(
    data = neigh_poly_metric,
    fillColor = ~pal_rich(unique_species),
    color = "#555",
    weight = 1,
    fillOpacity = 0.6,
    popup = ~label_rich  # FIX: use popup instead of label for HTML content
  ) |>
  addLegend("bottomright", pal = pal_rich, values = neigh_poly_metric$unique_species, title = "Unique species (neighbourhood)")
```

### A3. Near-water analysis

This table checks whether observations are disproportionately near water. It supports the narrative that lakeshore proximity is associated with higher observation activity.

```{r app_near_water}
water <- safe_read_sf(resolved$water)
water_clip <- suppressWarnings(st_intersection(st_make_valid(water), st_make_valid(aoi_buf)))
water_buf  <- st_transform(water_clip, AREA_CRS) |> st_buffer(WATER_BUF_M) |> st_transform(4326)

near_flag <- inat_clean |>
  mutate(near_water = lengths(st_intersects(geometry, water_buf)) > 0) |>
  st_drop_geometry() |>
  count(category, near_water) |>
  pivot_wider(names_from = near_water, values_from = n, values_fill = 0, names_prefix = "is_") |>
  transmute(category, near = `is_TRUE`, away = `is_FALSE`, share_near = round(near / (near + away), 3))

overall_share_near <- round(sum(near_flag$near) / sum(near_flag$near + near_flag$away), 3)
write_csv(near_flag, file.path(OUT_DIR, "near_water_by_category.csv"))

kbl(tibble(overall_share_near), caption = "Near-water share across all categories.")
kbl(near_flag, caption = "Near-water share by category.")
```

### A4. Top-10 species layered map

This interactive map shows where the most frequently reported species occur. It is included for interpretability and to support follow-up modelling choices (e.g., species-specific patterns).

```{r app_top10_species}
if ("scientific_name" %in% names(inat_clean)) {
  top10_species <- inat_clean |> st_drop_geometry() |> count(scientific_name, sort = TRUE) |> slice_head(n = 10) |> pull(scientific_name)
  inat_top <- filter(inat_clean, scientific_name %in% top10_species)

  pal_sp <- colorFactor("Set1", domain = sort(unique(st_drop_geometry(inat_top)$scientific_name)))
  popup_sp <- ~paste0(
    "<b>", scientific_name, "</b>",
    if ("observed_on" %in% names(inat_top)) paste0("<br/>Date: ", observed_on) else "",
    if ("user_login"  %in% names(inat_top)) paste0("<br/>Observer: ", user_login) else ""
  )
  species_groups <- sort(unique(st_drop_geometry(inat_top)$scientific_name))

  m_top <- leaflet(options = leafletOptions(minZoom = 10)) |>
    addProviderTiles("CartoDB.Positron") |>
    addPolygons(data = aoi_buf, label = "AOI (union) buffer", color = "#444", weight = 2, fillOpacity = 0.05)

  for (sp in species_groups) {
    m_top <- m_top |>
      addCircleMarkers(
        data = filter(inat_top, scientific_name == sp),
        radius = 3,
        color = pal_sp(sp),
        stroke = FALSE,
        fillOpacity = 0.9,
        popup = popup_sp,
        group = sp,
        clusterOptions = markerClusterOptions(spiderfyOnMaxZoom = TRUE)
      )
  }

  m_top <- m_top |>
    addLayersControl(overlayGroups = species_groups, options = layersControlOptions(collapsed = FALSE)) |>
    addLegend("bottomright", pal = pal_sp, values = ~scientific_name, data = st_drop_geometry(inat_top), title = "Top 10 species")

  saveWidget(m_top, file.path(OUT_DIR, "map_top10_species.html"), selfcontained = TRUE)
  m_top
}
```

### A5. Per-year layered map

This map visualizes whether the spatial footprint of observations changes by year. It complements Fig 3 by showing whether increases are broad-based or localized.

```{r app_by_year}
if ("observed_on" %in% names(inat_clean)) {
  inat_year <- inat_clean |>
    mutate(year_obs = format(as.Date(observed_on), "%Y")) |>
    filter(!is.na(year_obs))

  years <- sort(unique(st_drop_geometry(inat_year)$year_obs))
  pal_year <- colorFactor("magma", domain = years)

  m_year <- leaflet() |>
    addProviderTiles("CartoDB.Positron") |>
    addPolygons(data = aoi_buf, color = "lightblue", weight = 2, fillOpacity = 0.05)

  for (yy in years) {
    m_year <- m_year |> addCircles(
      data  = subset(inat_year, year_obs == yy),
      group = yy,
      color = ~pal_year(year_obs),
      radius = 1,
      opacity = 1,
      weight = 3
    )
  }

  m_year <- m_year |>
    addLegend("bottomright", pal = pal_year, values = years, opacity = 1) |>
    addLayersControl(position = "topright", overlayGroups = years, options = layersControlOptions(collapsed = FALSE))

  saveWidget(m_year, file.path(OUT_DIR, "map_by_year.html"), selfcontained = TRUE)
  m_year
}
```

### A6. Top-5 species by area (tables)

These tables summarize the dominant species within each spatial unit. They help interpret differences in richness and composition across areas.

```{r app_top5_by_area}
areas_for_table <- list(
  `Beach BIA` = beach_bia,
  `Woodbine Beach` = beach,
  `AOI buffer (union)` = aoi_buf
)
if (exists("neigh_beaches") && !is.null(neigh_beaches) && nrow(neigh_beaches) > 0) {
  areas_for_table[["The Beaches (Neighbourhood)"]] <- neigh_beaches
}

topN_area <- function(poly, N = 5) {
  pts <- suppressWarnings(st_filter(inat_clean, poly))
  pts |> st_drop_geometry() |> count(scientific_name, sort = TRUE) |> slice_head(n = N)
}

top_by_area <- purrr::imap(areas_for_table, ~ topN_area(.x, N = 5) |> mutate(area = .y)) |>
  bind_rows() |>
  relocate(area)

write_csv(top_by_area, file.path(OUT_DIR, "top5_species_by_area.csv"))
kbl(top_by_area, caption = "Top 5 species by observation count within each spatial unit.")
```

### A7. Mini data dictionary

This dictionary documents exported outputs for reproducibility and grading transparency.

```{r app_dictionary}
dict <- tibble::tribble(
  ~file, ~column, ~meaning,
  "bio_summary_final.csv", "total_obs", "iNat observations inside AOI",
  "bio_summary_final.csv", "unique_species", "distinct scientific_name",
  "bio_summary_final.csv", "tree_points", "tree records inside AOI",
  "bio_summary_final.csv", "area_ha", "AOI area (hectares)",
  "bio_summary_final.csv", "species_per_ha", "unique_species / area_ha",
  "bio_summary_final.csv", "aoi_buffer_m", "AOI buffer distance (meters)",
  "neighbourhood_biodiversity_summary.csv", "neigh", "neighbourhood name",
  "neighbourhood_biodiversity_summary.csv", "unique_species", "species within neighbourhood AOI",
  "neighbourhood_biodiversity_summary.csv", "area_ha", "neighbourhood area in AOI (ha)",
  "neighbourhood_biodiversity_summary.csv", "species_per_ha", "unique_species / area_ha",
  "near_water_by_category.csv", "share_near", "near / (near + away)",
  "tree_density_by_area.csv", "trees_per_km2", "tree_points / area_km2"
)
write_csv(dict, file.path(OUT_DIR, "outputs_data_dictionary.csv"))
kbl(dict, caption = "Outputs data dictionary.")
```

</details>
