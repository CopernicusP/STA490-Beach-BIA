---
title: "Biodiversity EDA — Peter (Individual)"
author: "Yudian (Peter) Pan"
date: "`r format(Sys.Date(), '%B %d, %Y')`"
output:
  html_document:
    toc: true
    toc_depth: 2
    toc_float: true
    number_sections: false
    code_folding: hide
    theme: flatly
    css: peter_eda.css
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = FALSE,
  message = FALSE,
  warning = FALSE,
  fig.align = "center",
  fig.width = 8,
  fig.height = 4.5,
  out.width = "95%"
)

suppressPackageStartupMessages({
  library(sf)
  library(dplyr)
  library(readr)
  library(stringr)
  library(janitor)
  library(glue)
  library(leaflet)
  library(purrr)
  library(ggplot2)
  library(lubridate)
  library(tibble)
  library(tidyr)
  library(htmlwidgets)
  library(rlang)
  library(knitr)
})

# ---------------- Parameters ----------------
AOI_BUFFER_M <- 30              # AOI buffer distance (meters)
WATER_BUF_M  <- 20              # Near-water buffer (meters)
START_DATE   <- as.Date("2020-01-01")

# Toggle console-like debug output inside HTML
VERBOSE <- FALSE
msg <- function(...) if (isTRUE(VERBOSE)) message(glue::glue(...)) else invisible(NULL)

# ---------------- Project root detection ----------------
wd <- getwd()
root_candidates <- unique(c(
  wd,
  normalizePath(file.path(wd, ".."), mustWork = FALSE),
  normalizePath(file.path(wd, "..", ".."), mustWork = FALSE),
  normalizePath(file.path(wd, "..", "..", ".."), mustWork = FALSE),
  normalizePath(file.path(wd, "..", "..", "..", ".."), mustWork = FALSE)
))

ROOT <- wd
for (cand in root_candidates) {
  if (dir.exists(file.path(cand, "Data")) || dir.exists(file.path(cand, "Dataset")) ||
      dir.exists(file.path(cand, "data")) || dir.exists(file.path(cand, "datasets"))) {
    ROOT <- cand
    break
  }
}

# ---------------- Paths ----------------
OUT_DIR <- file.path(ROOT, "Results", "Biodiversity_Peter")
FIG_DIR <- file.path(ROOT, "Figures", "Biodiversity_Peter")
dir.create(OUT_DIR, showWarnings = FALSE, recursive = TRUE)
dir.create(FIG_DIR, showWarnings = FALSE, recursive = TRUE)

DATA_DIRS <- unique(c(
  ROOT,
  wd,
  file.path(ROOT, "Data"),
  file.path(ROOT, "Dataset"),
  file.path(ROOT, "data"),
  "/mnt/data"
))

# Find the first file matching a regex pattern across all roots
find_first <- function(pattern, required = TRUE) {
  files <- unlist(lapply(DATA_DIRS, function(root) {
    if (!dir.exists(root)) return(character(0))
    list.files(root, pattern = pattern, recursive = TRUE, full.names = TRUE)
  }))
  if (length(files)) return(files[1])
  if (required) stop(glue("Missing file for pattern: {pattern}"))
  NA_character_
}

# Find a vector dataset (prefer GeoJSON; else complete SHP)
find_vector <- function(base_pat, prefer_geojson = TRUE, required = TRUE){
  if (prefer_geojson) {
    gj <- unlist(lapply(DATA_DIRS, function(root) {
      if (!dir.exists(root)) return(character(0))
      list.files(root, pattern = glue("{base_pat}.*\\.geojson$"), recursive = TRUE, full.names = TRUE)
    }))
    if (length(gj)) return(gj[1])
  }
  shp <- find_first(glue("{base_pat}.*\\.shp$"), required = required)
  if (is.na(shp)) return(NA_character_)
  stem <- sub("\\.shp$", "", shp, ignore.case = TRUE)
  need <- paste0(stem, c(".shx", ".dbf"))
  if (!all(file.exists(need))) stop(glue("Incomplete SHP for {basename(shp)}"))
  shp
}

# Read sf and ensure EPSG:4326 (FIX: safer CRS check)
safe_read_sf <- function(f){
  x <- suppressMessages(st_read(f, quiet = TRUE))
  crs_epsg <- st_crs(x)$epsg
  if (!is.na(st_crs(x)) && !is.null(crs_epsg) && crs_epsg != 4326L) {
    x <- st_transform(x, 4326)
  }
  x
}

# turn off s2 globally for this knit (avoid spherical union issues)
sf::sf_use_s2(FALSE)

# Helper for nicer HTML tables
kbl <- function(x, caption = NULL) {
  knitr::kable(x, caption = caption, digits = 3)
}

# Helper function: find polygon by name pattern (FIX: reduce code duplication)
find_polygon_by_name <- function(sf_obj, pattern, fallback_all = FALSE) {
  chr_cols <- names(sf_obj)[vapply(sf_obj, function(x) is.character(x) || is.factor(x), logical(1))]
  hits <- sapply(chr_cols, function(col) sum(str_detect(as.character(sf_obj[[col]]), pattern), na.rm = TRUE))
  if (length(hits) && max(hits) > 0) {
    best <- names(which.max(hits))
    sf_obj[str_detect(as.character(sf_obj[[best]]), pattern), ]
  } else if (fallback_all) {
    sf_obj
  } else {
    NULL
  }
}

# Helper: safely get first value or NA
safe_first <- function(x, default = NA_real_) {

  if (length(x) == 0 || all(is.na(x))) return(default)

  x[1]
}
```

```{r data_pipeline, include=FALSE}
# ---------------- Resolve files ----------------
inat_csv <- NA_character_
for (pat in c("observations-631589\\.csv$", "observations-624727\\.csv$", "observations\\.csv$")) {
  candidate <- tryCatch(find_first(pat, required = FALSE), error = function(e) NA_character_)
  if (!is.na(candidate)) { inat_csv <- candidate; break }
}
if (is.na(inat_csv)) stop("iNaturalist CSV not found. Expected e.g. observations-631589.csv")

resolved <- list(
  inat_csv = inat_csv,
  bia      = find_vector("Business.*Areas.*4326"),
  green    = find_vector("Green.*Spaces.*4326"),
  neigh    = find_vector("Neighbourhoods.*4326"),
  trees    = find_vector("TOPO_TREE_WGS84",      prefer_geojson = FALSE),
  water    = find_vector("TOPO_Waterbody_WGS84", prefer_geojson = FALSE),
  woodbine = {
    wb <- unlist(lapply(DATA_DIRS, function(root) {
      if (!dir.exists(root)) return(character(0))
      list.files(root, pattern = "WoodbineBeach.shp$", recursive = TRUE, full.names = TRUE)
    }))
    if (length(wb)) wb[1] else NA_character_
  }
)

# ---------------- AOI + cache ----------------
inat_gj <- file.path(OUT_DIR,"inat_aoi.geojson")
tree_gj <- file.path(OUT_DIR,"trees_aoi.geojson")
aoi_gj  <- file.path(OUT_DIR,"aoi_union_buffer.geojson")

use_cached <- file.exists(inat_gj) && file.exists(tree_gj) && file.exists(aoi_gj)

if (use_cached) {
  inat_aoi  <- safe_read_sf(inat_gj)
  trees_aoi <- safe_read_sf(tree_gj)
  aoi_buf   <- safe_read_sf(aoi_gj)
} else {
  # ---- iNaturalist points ----
  inat <- read_csv(resolved$inat_csv, show_col_types = FALSE) |>
    clean_names() |>
    mutate(
      latitude  = as.numeric(latitude),
      longitude = as.numeric(longitude)
    ) |>
    filter(!is.na(latitude), !is.na(longitude),
           between(latitude,-90,90), between(longitude,-180,180))
  inat_sf <- st_as_sf(inat, coords = c("longitude","latitude"), crs = 4326, remove = FALSE)

  # ---- Base layers ----
  bia   <- safe_read_sf(resolved$bia)
  green <- safe_read_sf(resolved$green)
  trees <- safe_read_sf(resolved$trees)
  neigh <- safe_read_sf(resolved$neigh)

  # ---- Pick Beach BIA by name (robust) ----
  pat_bia <- regex("(^|\\b)(the\\s*beach|the\\s*beaches|beach|beaches)(\\b|$)", ignore_case = TRUE)
  beach_bia <- find_polygon_by_name(bia, pat_bia, fallback_all = TRUE)

  # ---- Woodbine polygon (from Green Spaces or dedicated SHP) ----
  beach <- if (!is.na(resolved$woodbine)) {
    tryCatch(safe_read_sf(resolved$woodbine), error = function(e) NULL)
  } else NULL

  if (is.null(beach) || nrow(beach) == 0) {
    gr_chr <- names(green)[vapply(green, function(x) is.character(x) || is.factor(x), logical(1))]
    idx <- Reduce(`|`, lapply(gr_chr, function(col) str_detect(tolower(green[[col]]), "woodbine")))
    beach <- green[idx,]
    if (nrow(beach) == 0) stop("No 'Woodbine' polygon found in Green Spaces.")
  }

  # ---- Neighbourhood: 'The Beaches' (by name; fallback to code 93 if present) ----
  pat_nb <- regex("(^|\\b)the\\s*beaches(\\b|$)", ignore_case = TRUE)
  neigh_beaches <- find_polygon_by_name(neigh, pat_nb, fallback_all = FALSE)
  if (is.null(neigh_beaches) && "X_id1" %in% names(neigh) && any(neigh$X_id1 == 93, na.rm = TRUE)) {
    neigh_beaches <- neigh |> dplyr::filter(.data$X_id1 == 93)
  }

  # ---- AOI = union(BIA, Woodbine, The Beaches) + buffer (planar) ----
  sanitize <- function(g) {
    g <- st_make_valid(g)
    suppressWarnings(st_collection_extract(g, "POLYGON"))
  }
  parts <- list(sanitize(beach_bia), sanitize(beach))
  if (!is.null(neigh_beaches) && nrow(neigh_beaches) > 0) parts <- c(parts, list(sanitize(neigh_beaches)))

  geoms_4326 <- do.call(c, lapply(parts, st_geometry))
  geoms_proj <- st_transform(geoms_4326, 32617)
  aoi_comb   <- st_combine(geoms_proj)
  aoi_planar <- st_union(aoi_comb)
  aoi_buf    <- st_buffer(aoi_planar, AOI_BUFFER_M) |> st_transform(4326)

  # ---- Filter layers by AOI ----
  inat_aoi  <- st_filter(inat_sf, aoi_buf)
  trees_aoi <- st_filter(trees,   aoi_buf)

  # ---- Write cache ----
  st_write(inat_aoi,  inat_gj, delete_dsn = TRUE, quiet = TRUE)
  st_write(trees_aoi, tree_gj, delete_dsn = TRUE, quiet = TRUE)
  st_write(aoi_buf,   aoi_gj,  delete_dsn = TRUE, quiet = TRUE)

  # Keep key polygons for later summaries (FIX: use <<- instead of assign to GlobalEnv)
  beach_bia <<- beach_bia
  beach <<- beach
  if (!is.null(neigh_beaches)) neigh_beaches <<- neigh_beaches
}

# If we came from cache, (re)load polygons for later summaries
if (!exists("beach_bia") || !exists("beach")) {
  bia   <- safe_read_sf(resolved$bia)
  green <- safe_read_sf(resolved$green)

  pat_bia <- regex("(^|\\b)(the\\s*beach|the\\s*beaches|beach|beaches)(\\b|$)", ignore_case = TRUE)
  beach_bia <- find_polygon_by_name(bia, pat_bia, fallback_all = TRUE)

  gr_chr <- names(green)[vapply(green, function(x) is.character(x) || is.factor(x), logical(1))]
  idx <- Reduce(`|`, lapply(gr_chr, function(col) str_detect(tolower(green[[col]]), "woodbine")))
  beach <- green[idx,]
}

# ---------------- iNat cleaning + classification ----------------
iconic_candidates <- intersect(c("iconic_taxon_name", "taxon_iconic_name"), names(inat_aoi))

inat_clean <- inat_aoi |>
  mutate(
    iconic_tmp = if (length(iconic_candidates) > 0) {
      dplyr::coalesce(!!! rlang::syms(iconic_candidates))
    } else NA_character_,
    category = case_when(
      str_detect(iconic_tmp, regex("Plantae",  TRUE)) ~ "Plants",
      str_detect(iconic_tmp, regex("Aves",     TRUE)) ~ "Birds",
      str_detect(iconic_tmp, regex("Insecta",  TRUE)) ~ "Insects",
      str_detect(iconic_tmp, regex("Mammalia", TRUE)) ~ "Mammals",
      str_detect(iconic_tmp, regex("Reptilia", TRUE)) ~ "Reptiles",
      str_detect(iconic_tmp, regex("Arachnida",TRUE)) ~ "Spiders",
      TRUE ~ "Other"
    )
  ) |>
  select(-iconic_tmp)

id_col <- intersect(c("id", "observation_id"), names(inat_clean))[1]
if (!is.na(id_col) && nzchar(id_col)) {
  id_sym <- rlang::sym(id_col)
  inat_clean <- inat_clean |> arrange(!!id_sym) |> distinct(!!id_sym, .keep_all = TRUE)
}

inat_research <- if ("quality_grade" %in% names(inat_clean)) {
  filter(inat_clean, quality_grade == "research")
} else inat_clean

# ---------------- Summary tables + exports ----------------
AREA_CRS <- 32617
area_ha <- aoi_buf |> st_transform(AREA_CRS) |> st_area() |> as.numeric() / 10000
species_n <- if ("scientific_name" %in% names(inat_clean)) n_distinct(inat_clean$scientific_name) else NA_integer_

summary_tbl <- tibble(
  total_obs      = nrow(inat_clean),
  unique_species = species_n,
  tree_points    = nrow(trees_aoi),
  area_ha        = round(sum(area_ha), 2),
  species_per_ha = round(species_n / sum(area_ha), 3),
  aoi_buffer_m   = AOI_BUFFER_M
)

write_csv(summary_tbl, file.path(OUT_DIR, "bio_summary_final.csv"))

cat_summary <- inat_clean |> st_drop_geometry() |> count(category, name = "observations") |> arrange(desc(observations))
write_csv(cat_summary, file.path(OUT_DIR, "category_summary.csv"))

# Multi-area summary (BIA vs Woodbine vs Neighbourhood vs AOI)
summarise_area <- function(name, poly){
  poly <- st_make_valid(poly)
  a_ha <- st_area(st_transform(poly, AREA_CRS)) |> as.numeric() / 10000
  inat_s  <- suppressWarnings(st_filter(inat_clean, poly))
  trees_s <- suppressWarnings(st_filter(trees_aoi,   poly))
  tibble(
    area           = name,
    total_obs      = nrow(inat_s),
    unique_species = if ("scientific_name" %in% names(inat_s)) n_distinct(inat_s$scientific_name) else NA_integer_,
    tree_points    = nrow(trees_s),
    area_ha        = round(sum(a_ha), 2),
    species_per_ha = round(n_distinct(inat_s$scientific_name) / sum(a_ha), 3)
  )
}

areas_list <- list(
  "Beach BIA" = beach_bia,
  "Woodbine Beach" = beach,
  "AOI buffer (union)" = aoi_buf
)
if (exists("neigh_beaches") && !is.null(neigh_beaches) && nrow(neigh_beaches) > 0) {
  areas_list[["The Beaches (Neighbourhood)"]] <- neigh_beaches
}

summary_by_area <- bind_rows(purrr::imap(areas_list, ~ summarise_area(.y, .x)))
write_csv(summary_by_area, file.path(OUT_DIR, "bio_summary_by_area.csv"))

# Tree density (trees per km^2)
tree_density_tbl <- summary_by_area |>
  mutate(
    area_km2 = area_ha / 100,
    trees_per_km2 = ifelse(area_km2 > 0, tree_points / area_km2, NA_real_)
  ) |>
  select(area, tree_points, area_ha, trees_per_km2) |>
  arrange(area)

write_csv(tree_density_tbl, file.path(OUT_DIR, "tree_density_by_area.csv"))

# Time series helper objects
if ("observed_on" %in% names(inat_clean)) {
  yearly <- inat_clean |>
    st_drop_geometry() |>
    mutate(date = as.Date(observed_on)) |>
    filter(!is.na(date), date >= START_DATE) |>
    count(year = lubridate::year(date), name = "observations") |>
    arrange(year)

  monthly <- inat_clean |>
    st_drop_geometry() |>
    mutate(date = as.Date(observed_on)) |>
    filter(!is.na(date), date >= START_DATE) |>
    count(month = lubridate::floor_date(date, "month"), name = "n")
} else {
  yearly  <- NULL
  monthly <- NULL
}

# Convenience exports from consolidated workflow
if ("scientific_name" %in% names(inat_clean)) {
  top_species_tbl <- inat_clean |> st_drop_geometry() |> count(scientific_name, sort = TRUE) |> slice_head(n = 10)
  write_csv(top_species_tbl, file.path(OUT_DIR, "top_species.csv"))
}
if ("user_login" %in% names(inat_clean)) {
  top_observers_tbl <- inat_clean |> st_drop_geometry() |> count(user_login, sort = TRUE) |> slice_head(n = 10)
  write_csv(top_observers_tbl, file.path(OUT_DIR, "top_observers.csv"))
}
```

# Introduction

This individual report provides an exploratory analysis of biodiversity-related features within **The Beach BIA** area. The analysis uses iNaturalist observations together with spatial layers (tree inventory, greenspaces, and waterbodies) to (i) identify **where** observations are concentrated and (ii) summarize **how** observation volume varies across time and across spatial units (Beach BIA vs Woodbine Beach vs the broader AOI). Unless stated otherwise, summaries and plots refer to the AOI (union + buffer), with specific comparisons reported for the Beach BIA and Woodbine Beach where relevant.

iNaturalist is a citizen-science platform where people upload georeferenced observations of organisms (often with photos). Observations are identified by users and may be validated through community consensus, which makes the dataset useful for exploratory biodiversity analysis. However, because data are contributed voluntarily, iNaturalist also reflects reporting bias (e.g., where people go and what they notice), so results should be interpreted as a combined signal of biodiversity presence and public engagement.

To keep this deliverable consistent with our group work, the data pipeline and spatial definitions reuse the same consolidated workflow (AOI union + buffer, consistent CRS handling, and the same iNaturalist classification rules). This document is written in a **report-style HTML format** (text + figure, minimal console noise) so it can be submitted as a standalone artifact.

# Research objectives

This EDA focuses on two questions:

1. **iNaturalist patterns:** Are there identifiable spatial and temporal patterns in the number of observations inside the AOI?
2. **Tree density:** How does tree density vary across the Beach BIA commercial strip relative to nearby areas?

These questions matter because they translate citizen-science biodiversity signals into place-based insights for the Beach BIA. Understanding where observations cluster and how they change over time can highlight potential “biodiversity touchpoints” and seasonality patterns that are relevant for outreach, stewardship, and neighbourhood engagement. Comparing tree density across the Beach BIA and a nearby waterfront park provides a complementary view of urban canopy structure, which is closely related to walkability, thermal comfort, and local greening priorities.

# Data description

This analysis integrates four datasets. iNaturalist observations (CSV) provide community-reported, georeferenced sightings and serve as a proxy for biodiversity presence and engagement. The City of Toronto tree inventory (vector layer) provides point locations for recorded trees and supports canopy-related comparisons. Greenspace and waterbody polygon layers provide contextual natural features that help interpret spatial clustering in observations. Finally, the Beach BIA boundary and the Woodbine Beach polygon define the focal commercial strip and a nearby waterfront comparator, enabling comparisons across the BIA, the adjacent park area, and the broader AOI.

# Methods and data preparation

## Area of interest (AOI)

The AOI is constructed as the **union** of: (i) the Beach BIA polygon, (ii) the Woodbine Beach polygon, and (iii) (when available) the broader "The Beaches" neighbourhood polygon, followed by a **buffer of `r AOI_BUFFER_M` meters** to capture nearby observations at the boundary. All spatial operations are performed in a projected CRS for buffering/union, then returned to EPSG:4326 for mapping.

## Cleaning and classification

In this report, data cleaning refers to preprocessing steps that improve consistency and usability of the raw records (e.g., removing unusable rows, standardizing fields, and ensuring valid geometry). Classification refers to grouping each iNaturalist observation into broad biological categories to support high-level summaries. Specifically, we converted iNaturalist observations into spatial features and defined the AOI using a buffer around the Beach BIA boundary; aligned coordinate reference systems (CRS) across spatial layers to ensure valid overlay operations; and used the iNaturalist “iconic taxon” field to classify observations into broad groups for composition summaries and mapping.

## Summary Statistics

```{r tbl_summary, echo=FALSE}
kbl(summary_tbl, caption = "Table 1. Summary statistics for the AOI used in the biodiversity EDA.")
```

Table 1 summarizes the scale of the filtered AOI dataset. In total, the AOI contains 10,450 iNaturalist observations representing 1,577 unique species across 431.54 ha, corresponding to 3.654 species per ha. The same AOI contains 9,137 recorded tree points, and the AOI definition uses a 30 m buffer around the union polygon. These values provide context for interpreting the spatial and temporal figures below: high observation totals can reflect ecological richness, higher visitation/reporting intensity, or both, so results are interpreted with potential reporting bias in mind.

# Exploratory data analysis

## Question 1 — Spatial and temporal patterns in iNaturalist observations

### Fig 1. Spatial distribution of observations and trees

The map below overlays iNaturalist observations (grouped by broad category) and tree points within the AOI. Visual clustering near greenspaces and the lakeshore suggests that biodiversity observations are not uniformly distributed across the district; instead, they tend to concentrate around natural corridors and park-like areas.

```{r fig1_map_categories_trees}
m <- leaflet(options = leafletOptions(minZoom = 10)) |>
  addProviderTiles("CartoDB.Positron") |>
  addPolygons(data = aoi_buf, label = "AOI (union) buffer", color = "#444", weight = 2, fillOpacity = 0.05) |>
  addCircleMarkers(data = filter(inat_clean, category == "Plants"),   radius = 2, color = "#2ca25f", stroke = FALSE, fillOpacity = 0.9, group = "Plants") |>
  addCircleMarkers(data = filter(inat_clean, category == "Birds"),    radius = 2, color = "#3182bd", stroke = FALSE, fillOpacity = 0.9, group = "Birds") |>
  addCircleMarkers(data = filter(inat_clean, category == "Insects"),  radius = 2, color = "#fd8d3c", stroke = FALSE, fillOpacity = 0.9, group = "Insects") |>
  addCircleMarkers(data = filter(inat_clean, category == "Mammals"),  radius = 2, color = "#756bb1", stroke = FALSE, fillOpacity = 0.9, group = "Mammals") |>
  addCircleMarkers(data = filter(inat_clean, category == "Reptiles"), radius = 2, color = "#41ab5d", stroke = FALSE, fillOpacity = 0.9, group = "Reptiles") |>
  addCircleMarkers(data = filter(inat_clean, category == "Spiders"),  radius = 2, color = "#636363", stroke = FALSE, fillOpacity = 0.9, group = "Spiders") |>
  addCircleMarkers(data = filter(inat_clean, category == "Other"),    radius = 2, color = "#969696", stroke = FALSE, fillOpacity = 0.8, group = "Other") |>
  addCircleMarkers(data = trees_aoi, radius = 2, color = "green", stroke = FALSE, fillOpacity = 0.6, group = "Trees") |>
  addLayersControl(
    overlayGroups = c("Plants","Birds","Insects","Mammals","Reptiles","Spiders","Other","Trees"),
    options = layersControlOptions(collapsed = FALSE)
  ) |>
  addLegend(
    "bottomright",
    colors = c("#2ca25f","#3182bd","#fd8d3c","#756bb1","#41ab5d","#636363","#969696","green"),
    labels = c("Plants","Birds","Insects","Mammals","Reptiles","Spiders","Other","Trees"),
    title = "Layers"
  )

m

# Save a standalone copy (optional; useful for sharing outside the knitted report)
saveWidget(m, file.path(OUT_DIR, "map_categories_and_trees.html"), selfcontained = TRUE)
```

Overall, the map suggests that observations are spatially clustered rather than uniform, which is consistent with the existence of local hotspots that may be driven by greenspace access and pedestrian activity. This supports RQ1 by indicating that biodiversity-related signals (and/or reporting intensity) concentrate in specific locations. A key caveat is that clustering can be influenced by accessibility and user behaviour, not only ecological factors.

### Fig 2. Composition of observations by broad category

The figure below summarizes the distribution of observations across broad categories. Because iNaturalist is user-driven, this composition reflects both ecological presence and observer behavior (e.g., which taxa are easier to detect and report).

```{r fig2_obs_by_category, fig.cap="Figure 2. Observation counts by broad iNaturalist category inside the AOI."}
fig2_cat <- cat_summary |>
  mutate(category = factor(category, levels = category[order(observations, decreasing = TRUE)]))

p_cat <- ggplot(fig2_cat, aes(x = category, y = observations)) +
  geom_col() +
  labs(
    x = NULL,
    y = "Number of observations",
    title = "iNaturalist observations by species category (The Beach BIA AOI)"
  ) +
  theme_minimal()

p_cat

ggsave(file.path(FIG_DIR, "fig2_obs_by_category.png"), p_cat, width = 8, height = 4, dpi = 300)
```

Figure 2 shows that observations are dominated by a small number of broad groups—especially insects and birds, with plants also contributing a noticeable share. This pattern is plausible for a waterfront/greenspace-adjacent area, but it also reflects iNaturalist reporting behaviour: taxa that are visually salient and easy to photograph tend to be overrepresented, while other groups may be underreported. Therefore, composition should be interpreted as a combined signal of local biodiversity presence and observer effort rather than a complete census.

### Fig 3. Annual observation trend since 2020

Aggregating by year provides a simple view of temporal variation. In practice, changes over time can reflect both ecological variation and shifts in participation (more users, more reporting, or targeted observation events).

```{r fig3_annual_obs, fig.cap="Figure 3. Annual observation counts within the AOI (2020 to present)."}
if (!is.null(yearly)) {
  p_year <- ggplot(yearly, aes(x = factor(year), y = observations)) +
    geom_col() +
    labs(
      x = "Year",
      y = "Number of observations",
      title = "Annual iNaturalist observations in The Beach BIA AOI"
    ) +
    theme_minimal()

  print(p_year)
  ggsave(file.path(FIG_DIR, "fig3_annual_obs.png"), p_year, width = 8, height = 4, dpi = 300)
}
```

Figure 3 indicates an overall increase in reported observations from 2020–2023, a modest dip in 2024, and the highest level in 2025. Because iNaturalist participation can grow over time and recording effort is not constant across years, this trend should not be interpreted purely as ecological change. A more conservative interpretation is that observation volume reflects a mix of biodiversity presence, platform adoption, and user activity; future analyses could standardize by season or user activity to support more comparable year-to-year contrasts.

## Question 2 — Tree density along the commercial strip

To complement the spatial maps, we compute a simple density metric: **trees per km^2**, using each unit's area and the number of tree points that fall inside it.

```{r tbl_tree_density}
kbl(tree_density_tbl, caption = "Table 2. Tree density summary (trees per km^2) across spatial units.")
```

```{r tree_density_values, include=FALSE}
# FIX: Pre-compute values safely to avoid inline R code errors
density_bia <- safe_first(tree_density_tbl$trees_per_km2[tree_density_tbl$area == "Beach BIA"], 0)
density_woodbine <- safe_first(tree_density_tbl$trees_per_km2[tree_density_tbl$area == "Woodbine Beach"], 0)
density_aoi <- safe_first(tree_density_tbl$trees_per_km2[tree_density_tbl$area == "AOI buffer (union)"], 0)
```

Table 2 shows clear differences in tree density across spatial units. The AOI buffer (union) has the highest density at 2,117.301 trees per km^2, followed by the Beach BIA at 1,502.347 trees per km^2, while Woodbine Beach is substantially lower at 627.902 trees per km^2. This indicates that tree points are much more concentrated within the broader AOI and the BIA than within the Woodbine Beach polygon as defined in this analysis, and the comparison is sensitive to polygon boundaries and area estimates.

### Fig 4. Tree density heatmap inside the Beach BIA

The interactive heatmap emphasizes where tree points are most concentrated inside the Beach BIA polygon. This provides a visual complement to Table 2 by highlighting local clustering rather than a single area-average value.

```{r fig4_tree_heatmap}
if (requireNamespace("leaflet.extras", quietly = TRUE)) {
  trees_bia <- suppressWarnings(st_filter(trees_aoi, beach_bia))

  m_tree_heat <- leaflet(options = leafletOptions(minZoom = 10)) |>
    addProviderTiles("CartoDB.Positron") |>
    addPolygons(data = beach_bia, color = "#cc0000", weight = 2, fillOpacity = 0.05, group = "Beach BIA") |>
    leaflet.extras::addHeatmap(data = trees_bia, radius = 12, blur = 18, max = 0.6)

  saveWidget(m_tree_heat, file.path(OUT_DIR, "map_tree_density_heat.html"), selfcontained = TRUE)
  m_tree_heat
}
```

Figure 4 complements Table 2 by showing within-BIA variation rather than a single area-average density. Even though the Beach BIA has a lower overall tree density than nearby spatial units, the heatmap helps identify localized clusters versus comparatively sparse segments inside the BIA boundary. This visualization is useful for interpreting the density summary as spatially heterogeneous and for motivating follow-up work that relates canopy patterns to land use or street-level features.

# Conclusion

In conclusion, this EDA used iNaturalist observations and Toronto street-tree data to explore biodiversity-related patterns in and around the Beach BIA. Spatial visualizations suggest that observations are clustered rather than uniform, indicating potential hotspots that may reflect a combination of ecological features and reporting behaviour. Temporal and composition summaries provide additional context for interpreting these clusters and help frame how observation intensity varies across groups and years (RQ1). Tree density comparisons and the heatmap offer a complementary view of canopy structure across the Beach BIA and Woodbine Beach (RQ2).

Several limitations apply. iNaturalist data are user-generated and therefore subject to uneven sampling effort, reporting bias, and potential misidentification. Boundary definitions and buffer choices affect area-based rates, and tree inventories may be incomplete or updated over time. As a result, findings should be interpreted as comparative signals rather than definitive ecological measurements.

Future work could formalize hotspot detection (e.g., kernel density surfaces or spatial clustering tests), incorporate effort-adjusted or seasonally matched comparisons, and model observation counts using environmental predictors (distance to water/greenspace, canopy indicators). Benchmarking against similar neighbourhoods would also help contextualize whether the Beach BIA patterns are distinctive or typical.

# Appendix {-}

<details>
<summary><strong>Click to expand: additional exploration and saved outputs</strong></summary>

### A1. Monthly trend (optional)

This figure refines Fig 3 by showing within-year seasonality. Peaks likely reflect both ecological seasonality and reporting intensity.

```{r app_monthly}
if (!is.null(monthly)) {
  ggplot(monthly, aes(month, n)) +
    geom_col() +
    scale_x_date(date_labels = "%Y-%m", date_breaks = "2 months", expand = c(0.01,0.01)) +
    labs(x = "Month", y = "Observations", title = "iNaturalist observations per month") +
    theme_minimal() +
    theme(axis.text.x = element_text(angle = 45, hjust = 1))
}
```

### A2. Neighbourhood richness choropleth (within AOI)

This map compares neighbourhood-level richness (unique species) within the AOI. It helps identify which surrounding neighbourhoods may be driving the AOI-level totals.

```{r app_neigh_richness}
neigh <- safe_read_sf(resolved$neigh)
neigh_clip <- suppressWarnings(st_intersection(st_make_valid(neigh), st_make_valid(aoi_buf)))

neigh_name_col <- names(neigh_clip)[str_detect(names(neigh_clip), regex("NAME|NEIGH|AREA", TRUE))][1]
if (is.na(neigh_name_col)) neigh_name_col <- names(neigh_clip)[1]

inat_neigh <- st_join(inat_clean, neigh_clip, left = FALSE)

obs_by_neigh <- inat_neigh |> st_drop_geometry() |> count(neigh = .data[[neigh_name_col]], name = "obs")
sp_by_neigh  <- inat_neigh |> st_drop_geometry() |> group_by(neigh = .data[[neigh_name_col]]) |>
  summarise(unique_species = n_distinct(.data$scientific_name), .groups = "drop")

neigh_area <- neigh_clip |>
  mutate(area_ha = as.numeric(st_area(st_transform(geometry, AREA_CRS))) / 10000) |>
  st_drop_geometry() |>
  select(neigh = all_of(neigh_name_col), area_ha)

neigh_summary <- obs_by_neigh |>
  left_join(sp_by_neigh, by = "neigh") |>
  left_join(neigh_area,  by = "neigh") |>
  mutate(species_per_ha = round(unique_species / area_ha, 3)) |>
  arrange(desc(unique_species))

write_csv(neigh_summary, file.path(OUT_DIR, "neighbourhood_biodiversity_summary.csv"))

neigh_poly_metric <- neigh_clip |>
  left_join(neigh_summary, by = setNames("neigh", neigh_name_col)) |>
  mutate(label_rich = paste0(
    .data[[neigh_name_col]],
    "<br>Species: ", ifelse(is.na(unique_species), 0, unique_species),
    "<br>Area(ha): ", ifelse(is.na(area_ha), NA, round(area_ha, 1)),
    "<br>Sp/ha: ", ifelse(is.na(species_per_ha), NA, species_per_ha)
  ))

# FIX: safer colorBin with dynamic bins
n_unique <- length(unique(na.omit(neigh_poly_metric$unique_species)))
n_bins <- min(6, max(2, n_unique))
pal_rich <- colorBin("YlGnBu", neigh_poly_metric$unique_species, bins = n_bins, na.color = "#cccccc")

leaflet(options = leafletOptions(minZoom = 10)) |>
  addProviderTiles("CartoDB.Positron") |>
  addPolygons(
    data = neigh_poly_metric,
    fillColor = ~pal_rich(unique_species),
    color = "#555",
    weight = 1,
    fillOpacity = 0.6,
    popup = ~label_rich  # FIX: use popup instead of label for HTML content
  ) |>
  addLegend("bottomright", pal = pal_rich, values = neigh_poly_metric$unique_species, title = "Unique species (neighbourhood)")
```

### A3. Near-water analysis

This table checks whether observations are disproportionately near water. It supports the narrative that lakeshore proximity is associated with higher observation activity.

```{r app_near_water}
water <- safe_read_sf(resolved$water)
water_clip <- suppressWarnings(st_intersection(st_make_valid(water), st_make_valid(aoi_buf)))
water_buf  <- st_transform(water_clip, AREA_CRS) |> st_buffer(WATER_BUF_M) |> st_transform(4326)

near_flag <- inat_clean |>
  mutate(near_water = lengths(st_intersects(geometry, water_buf)) > 0) |>
  st_drop_geometry() |>
  count(category, near_water) |>
  pivot_wider(names_from = near_water, values_from = n, values_fill = 0, names_prefix = "is_") |>
  transmute(category, near = `is_TRUE`, away = `is_FALSE`, share_near = round(near / (near + away), 3))

overall_share_near <- round(sum(near_flag$near) / sum(near_flag$near + near_flag$away), 3)
write_csv(near_flag, file.path(OUT_DIR, "near_water_by_category.csv"))

kbl(tibble(overall_share_near), caption = "Near-water share across all categories.")
kbl(near_flag, caption = "Near-water share by category.")
```

### A4. Top-10 species layered map

This interactive map shows where the most frequently reported species occur. It is included for interpretability and to support follow-up modelling choices (e.g., species-specific patterns).

```{r app_top10_species}
if ("scientific_name" %in% names(inat_clean)) {
  top10_species <- inat_clean |> st_drop_geometry() |> count(scientific_name, sort = TRUE) |> slice_head(n = 10) |> pull(scientific_name)
  inat_top <- filter(inat_clean, scientific_name %in% top10_species)

  pal_sp <- colorFactor("Set1", domain = sort(unique(st_drop_geometry(inat_top)$scientific_name)))
  popup_sp <- ~paste0(
    "<b>", scientific_name, "</b>",
    if ("observed_on" %in% names(inat_top)) paste0("<br/>Date: ", observed_on) else "",
    if ("user_login"  %in% names(inat_top)) paste0("<br/>Observer: ", user_login) else ""
  )
  species_groups <- sort(unique(st_drop_geometry(inat_top)$scientific_name))

  m_top <- leaflet(options = leafletOptions(minZoom = 10)) |>
    addProviderTiles("CartoDB.Positron") |>
    addPolygons(data = aoi_buf, label = "AOI (union) buffer", color = "#444", weight = 2, fillOpacity = 0.05)

  for (sp in species_groups) {
    m_top <- m_top |>
      addCircleMarkers(
        data = filter(inat_top, scientific_name == sp),
        radius = 3,
        color = pal_sp(sp),
        stroke = FALSE,
        fillOpacity = 0.9,
        popup = popup_sp,
        group = sp,
        clusterOptions = markerClusterOptions(spiderfyOnMaxZoom = TRUE)
      )
  }

  m_top <- m_top |>
    addLayersControl(overlayGroups = species_groups, options = layersControlOptions(collapsed = FALSE)) |>
    addLegend("bottomright", pal = pal_sp, values = ~scientific_name, data = st_drop_geometry(inat_top), title = "Top 10 species")

  saveWidget(m_top, file.path(OUT_DIR, "map_top10_species.html"), selfcontained = TRUE)
  m_top
}
```

### A5. Per-year layered map

This map visualizes whether the spatial footprint of observations changes by year. It complements Fig 3 by showing whether increases are broad-based or localized.

```{r app_by_year}
if ("observed_on" %in% names(inat_clean)) {
  inat_year <- inat_clean |>
    mutate(year_obs = format(as.Date(observed_on), "%Y")) |>
    filter(!is.na(year_obs))

  years <- sort(unique(st_drop_geometry(inat_year)$year_obs))
  pal_year <- colorFactor("magma", domain = years)

  m_year <- leaflet() |>
    addProviderTiles("CartoDB.Positron") |>
    addPolygons(data = aoi_buf, color = "lightblue", weight = 2, fillOpacity = 0.05)

  for (yy in years) {
    m_year <- m_year |> addCircles(
      data  = subset(inat_year, year_obs == yy),
      group = yy,
      color = ~pal_year(year_obs),
      radius = 1,
      opacity = 1,
      weight = 3
    )
  }

  m_year <- m_year |>
    addLegend("bottomright", pal = pal_year, values = years, opacity = 1) |>
    addLayersControl(position = "topright", overlayGroups = years, options = layersControlOptions(collapsed = FALSE))

  saveWidget(m_year, file.path(OUT_DIR, "map_by_year.html"), selfcontained = TRUE)
  m_year
}
```

### A6. Top-5 species by area (tables)

These tables summarize the dominant species within each spatial unit. They help interpret differences in richness and composition across areas.

```{r app_top5_by_area}
areas_for_table <- list(
  `Beach BIA` = beach_bia,
  `Woodbine Beach` = beach,
  `AOI buffer (union)` = aoi_buf
)
if (exists("neigh_beaches") && !is.null(neigh_beaches) && nrow(neigh_beaches) > 0) {
  areas_for_table[["The Beaches (Neighbourhood)"]] <- neigh_beaches
}

topN_area <- function(poly, N = 5) {
  pts <- suppressWarnings(st_filter(inat_clean, poly))
  pts |> st_drop_geometry() |> count(scientific_name, sort = TRUE) |> slice_head(n = N)
}

top_by_area <- purrr::imap(areas_for_table, ~ topN_area(.x, N = 5) |> mutate(area = .y)) |>
  bind_rows() |>
  relocate(area)

write_csv(top_by_area, file.path(OUT_DIR, "top5_species_by_area.csv"))
kbl(top_by_area, caption = "Top 5 species by observation count within each spatial unit.")
```

### A7. Mini data dictionary

This dictionary documents exported outputs for reproducibility and grading transparency.

```{r app_dictionary}
dict <- tibble::tribble(
  ~file, ~column, ~meaning,
  "bio_summary_final.csv", "total_obs", "iNat observations inside AOI",
  "bio_summary_final.csv", "unique_species", "distinct scientific_name",
  "bio_summary_final.csv", "tree_points", "tree records inside AOI",
  "bio_summary_final.csv", "area_ha", "AOI area (hectares)",
  "bio_summary_final.csv", "species_per_ha", "unique_species / area_ha",
  "bio_summary_final.csv", "aoi_buffer_m", "AOI buffer distance (meters)",
  "neighbourhood_biodiversity_summary.csv", "neigh", "neighbourhood name",
  "neighbourhood_biodiversity_summary.csv", "unique_species", "species within neighbourhood AOI",
  "neighbourhood_biodiversity_summary.csv", "area_ha", "neighbourhood area in AOI (ha)",
  "neighbourhood_biodiversity_summary.csv", "species_per_ha", "unique_species / area_ha",
  "near_water_by_category.csv", "share_near", "near / (near + away)",
  "tree_density_by_area.csv", "trees_per_km2", "tree_points / area_km2"
)
write_csv(dict, file.path(OUT_DIR, "outputs_data_dictionary.csv"))
kbl(dict, caption = "Outputs data dictionary.")
```

</details>
